---
title: "p8105_hw5_dry2115"
author: "Dayoung Yu"
date: '`r format(Sys.time(), "%Y-%m-%d")`'
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%"
)

library(tidyverse)
library(modelr)
library(mgcv)

theme_set(theme_bw() + theme(legend.position = "bottom"))
```


### Problem 1

Read in and clean _Washington Post_ homicide data:

```{r}
homicide_df = 
  read_csv("data/homicide-data.csv", na = c("", "NA", "Unknown")) %>%
  mutate(
    city_state = str_c(city, state, sep = ", "),
    resolution = case_when(
      disposition == "Closed without arrest" ~ "unresolved",
      disposition == "Open/No arrest"        ~ "unresolved",
      disposition == "Closed by arrest"      ~ "resolved"),
    victim_race = case_when(
      victim_race == "White" ~ "white",
      victim_race != "White" ~ "non-white"),
    victim_age = as.numeric(victim_age)
    ) %>%
  filter(!(city_state %in% c("Dallas, TX", "Phoenix, AZ", "Kansas City, MO", "Tulsa, AL")))
```

The data set homicide_df contains gathered homicide data in 50 large U.S. cities, e.g., victim name and demographics, location, and disposition (whether case was closed and whether there was an arrest). The following changes were made: a new "city, state" variable was created, a new "resolution" variable was created defining whether the case was resolved or unresolved, and the "victim_race" was categorized as white or non-white. In addition, some cities were omitted due to missing data and error.


Logic regression for Baltimore homicides:

```{r}
baltimore_df = homicide_df %>%
  filter(city == "Baltimore") %>%
  mutate(resolved = as.numeric(resolution == "resolved")) %>%
  select(resolved, victim_age, victim_sex, victim_race)

baltimore_glm = baltimore_df %>%
  glm(resolved ~ victim_age + victim_sex + victim_race, data = ., family = binomial())

or_baltimore = baltimore_glm %>%
  broom::tidy() %>%
  mutate(OR = exp(estimate)) %>%
  select(term, log_OR = estimate, OR)

ci_baltimore = as.tibble(confint(baltimore_glm)) %>%
  janitor::clean_names() %>%
  select(ci_low = x2_5_percent, ci_high = x97_5_percent) %>%
  mutate(ci_low = exp(ci_low),
         ci_high = exp(ci_high))


cbind(or_baltimore, ci_baltimore) %>%
  filter(term == "victim_racewhite") %>%
  mutate(term = str_replace(term, "white", ": White")) %>%
  knitr::kable(digits = 3)

```

The table above shows the adjusted odds ratio and 95% confidence interval for solving homicides of whites vs. non-whites. Homicide cases of white victims have 2.27 times the odds of being resolved compared to homicide cases of non-white victims in the city of Baltimore.


Logic regression by city:

```{r}
city_glm = homicide_df %>%
  mutate(resolved = as.numeric(resolution == "resolved")) %>%
  group_by(city_state) %>%
  nest() %>%
  mutate(models = map(data, ~glm(resolved ~ victim_age + victim_sex + victim_race, data = ., family = binomial())),
         models = map(models, broom::tidy)) %>%
  select(-data) %>%
  unnest() %>%
  filter(term == "victim_racewhite") %>%
  mutate(OR = exp(estimate),
         ci_low = exp(estimate - 1.96*std.error),
         ci_high = exp(estimate + 1.96*std.error)) %>%
  select(city_state, term, log_OR = estimate, OR, ci_low, ci_high)
  

```

plot of ORs and CIs for each city

```{r}

city_glm %>%
  mutate(city_state = fct_reorder(city_state, OR)) %>%
  ggplot(aes(x = city_state, y = OR)) +
  geom_point() +
  geom_errorbar(aes(ymin = ci_low, ymax = ci_high)) +
   theme(axis.text.x = element_text(angle = 80, hjust = 1)) +
  labs(
    title = "Odds ratios for solving homicides in white vs. non-white victims",
    x = "City, State",
    y = "Estimated odds ratio"
  )


```

The plot above shows odds ratios and their confidence levels for solving homicides for white vs. non-white victims in 50 major U.S. cities. We can see that all odss ratios and confidence intervals are above zero, meaning that white victims have better odds of having a resolved case than non-white victims in all 50 major cities. The difference in odds between white and non-white victims is highest in Boston, but the confidence interval is also the widest meaning there is greater variance. 

### Problem 2

Read and clean data:
```{r}
birthweight_df = 
  read_csv("data/birthweight.csv") %>%
  mutate(babysex = as.factor(babysex),
         frace = as.factor(frace),
         malform = as.factor(malform),
         mrace = as.factor(mrace))


```

Variables _babysex_, _frace_, _malform_, and _mrace_ were converted from integer to factor type. 


Check for missing values:
```{r}
skimr::skim(birthweight_df) 
```
The data set had no missing values


Create model for birth weight:
Predictors were chosen based on results of a study identifying significant risk factors for low birth weight. The study can be found here: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4456878/
```{r}
birthweight_lm = lm(bwt ~ delwt + momage + gaweeks, data = birthweight_df)
  
birthweight_lm %>% broom::tidy()

birthweight_df %>%
  modelr::add_residuals(birthweight_lm) %>%
  modelr::add_predictions(birthweight_lm) %>%
  ggplot(aes(x = resid, y = pred)) +
  geom_point() 


```


compare with other models
```{r}
compare_lm1 = lm(bwt ~ blength + gaweeks, data = birthweight_df)

compare_lm2 = lm(bwt ~ bhead + blength + babysex +
                      bhead*blength + bhead*babysex + blength*babysex +
                      bhead*blength*babysex, data = birthweight_df)
```


cross validation
```{r}
cv_df = crossv_mc(birthweight_df, 100)

cv_df = 
  cv_df %>%
  mutate(birthweight_lm = map(train, ~ lm(bwt ~ delwt + momage + gaweeks, data = .x)),
         compare_lm1 = map(train, ~ lm(bwt ~ blength + gaweeks, data = .x)),
         compare_lm2 = map(train, ~ lm(bwt ~ bhead + blength + babysex +
                                       bhead*blength + bhead*babysex + blength*babysex +
                                       bhead*blength*babysex, data = .x))) %>%
  
  mutate(rmse_birthweight = map2_dbl(birthweight_lm, test, ~rmse(model = .x, data = .y)),
         rmse_compare1 = map2_dbl(compare_lm1, test, ~rmse(model = .x, data = .y)),
         rmse_compare2 = map2_dbl(compare_lm2, test, ~rmse(model = .x, data = .y)))
  
```


plot prediction error distribution for each candidate model

```{r}
cv_df %>% 
  select(starts_with("rmse")) %>% 
  gather(key = model, value = rmse) %>% 
  mutate(model = str_replace(model, "rmse_", ""),
         model = fct_inorder(model)) %>% 
  ggplot(aes(x = model, y = rmse)) + geom_violin()

```

